---
layout: post
title: "Azure AD B2C + SvelteKit: Building Auth Step by Step (Redirect Flow)"
description: "Deep dive into integrating Azure AD B2C into a modern SvelteKit (Svelte 5) app using MSAL redirect flow, reactive $state runes, and a lightweight context-driven auth service."
permalink: /azure-b2c/
last_modified: 2025-08-09
categories: [authentication, azure, sveltekit]
tags: [azure-ad-b2c, msal, sso, svelte, svelte5, spa-security]
---
## Why This Post

Modern SvelteKit (with Svelte 5 runes) plus Azure AD B2C makes for a powerful stack: strong enterprise identity with a highly reactive front-end. But official samples often feel over-engineered or React-centric. This article documents the *actual* lean implementation currently in this repository and then outlines pragmatic, incremental improvements you can layer on next.

This is not vapourware—every code reference below exists today unless explicitly marked as a future enhancement.

## Current Implementation Snapshot

"Ship small, extend later" is the guiding principle. Right now the auth layer consists of just two files:

| Role | File |
|------|------|
| Reactive auth service (context + state + MSAL integration) | `src/lib/auth/authState.svelte.ts` |
| Environment-aware configuration wrapper | `src/lib/auth/config.ts` |

Already working today:

- Redirect-based login & logout (Authorization Code + PKCE via MSAL)
- Silent token acquisition (basic refresh / rehydration)
- Reactive user/session state using `$state` rune
- Error capture & basic logging (MSAL log level configurable)
- Automatic post-login user provisioning call to `/api/auth/ensure-user`

Not implemented yet (roadmap — see later section):

- Centralized API client wrapper
- Reusable `<AuthGate>` / route guard helpers
- Role/claim-based UI gating
- Token caching strategy hardening (currently `localStorage` but we may shift to `sessionStorage`)
- Defensive clock skew handling & retry instrumentation

## Architecture Philosophy

Instead of scattering auth logic across +layout hooks or custom load functions, a single exported class instance (set into Svelte context) owns the lifecycle:

1. Initialize MSAL once (idempotent)
2. Process redirect result (after login or logout)
3. Discover existing account(s) & silently refresh
4. Expose ergonomic methods: `signIn`, `signOut`, `getAccessToken`
5. Maintain strongly-typed reactive state (auth flags, user identity, token, error)

Because it's a plain Svelte 5 rune-based class, consuming code stays clean and testable.

## Deep Dive: `authState.svelte.ts`

Key responsibilities inside the class:

1. Configuration hydration (default placeholders overridden by runtime config)
2. Controlled MSAL instance creation + `initialize()` call
3. Redirect handling via `handleRedirectPromise()`
4. Silent token acquisition with graceful `InteractionRequiredAuthError` fallback
5. User shape normalization (extracting `emails[0]`, `name`, `localAccountId`)
6. Opportunistic backend provisioning (`/api/auth/ensure-user` fire-and-forget)

### Token Storage Note

Right now the cache uses `localStorage`. For higher security (shorter persistence window; reduces impact of XSS) you may want to switch to `sessionStorage`:

```ts
cache: {
  cacheLocation: 'sessionStorage',
  storeAuthStateInCookie: false
}
```

This will be part of a forthcoming hardening pass.

### Simplified Usage Pattern

```svelte
<!-- +layout.svelte or a root component -->
<script lang="ts">
  import { setAuthState, getAuthState } from '$lib/auth/authState.svelte';
  import { azureB2CConfig } from '$lib/auth/config';

  const auth = setAuthState();
  auth.initializeMsal(azureB2CConfig); // fire early
</script>

<slot />
```

Then in any leaf component:

```svelte
<script lang="ts">
  import { getAuthState } from '$lib/auth/authState.svelte';
  const auth = getAuthState();

  async function callApi() {
    const token = await auth.getAccessToken();
    if (!token) return;
    const res = await fetch('/api/secure-endpoint', {
      headers: { Authorization: `Bearer ${token}` }
    });
    console.log(await res.json());
  }
</script>

{#if auth.isLoading}
  <p>Loading session...</p>
{:else if auth.isAuthenticated}
  <p>Welcome {auth.user?.displayName || auth.user?.email}</p>
  <button onclick={auth.signOut}>Sign out</button>
  <button onclick={callApi}>Test API</button>
{:else}
  <button onclick={auth.signIn}>Sign in</button>
{/if}

{#if auth.error}
  <p class="error">{auth.error}</p>
{/if}
```

## Configuration (`config.ts`)

The config module abstracts environment variability between server and browser contexts, prioritizing `process.env` on the server and `import.meta.env` (Vite-exposed, `VITE_` prefix) in the browser. This avoids leaking secrets inadvertently.

Example (already present):

```ts
clientId: getEnvVar('AZURE_B2C_CLIENT_ID', '<fallback-guid>');
authority: getEnvVar('AZURE_B2C_AUTHORITY', 'https://tenant.b2clogin.com/...');
knownAuthorities: [getEnvVar('AZURE_B2C_KNOWN_AUTHORITY', 'tenant.b2clogin.com')];
```

You can inject overrides during `initializeMsal(config)` if you need to swap policies (e.g., password reset vs sign-up) on demand.

## Azure AD B2C Tenant Setup (Recap)

1. Create / select B2C tenant
2. Register a SPA application
3. Configure redirect URIs: `http://localhost:5173` (and any others you expect, e.g. `/auth`) 
4. Create user flow: e.g. `B2C_1_SignInSignUp`
5. (Optional) Add password reset + profile edit flows
6. Expose API scopes later if you have a protected backend

Record these values (map to env vars):

| Variable | Meaning |
|----------|---------|
| AZURE_B2C_CLIENT_ID | App (client) ID |
| AZURE_B2C_AUTHORITY | Full authority incl. policy |
| AZURE_B2C_KNOWN_AUTHORITY | Host of the B2C tenant |
| AZURE_B2C_REDIRECT_URI | SPA redirect URI |
| AZURE_B2C_POST_LOGOUT_REDIRECT_URI | Where logout returns |

## Environment Variables

`.env.local` (do not commit):

```
AZURE_B2C_CLIENT_ID=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
AZURE_B2C_AUTHORITY=https://yourtenant.b2clogin.com/yourtenant.onmicrosoft.com/B2C_1_SignInSignUp
AZURE_B2C_KNOWN_AUTHORITY=yourtenant.b2clogin.com
AZURE_B2C_REDIRECT_URI=http://localhost:5173
AZURE_B2C_POST_LOGOUT_REDIRECT_URI=http://localhost:5173
```

If you need them in the browser, *also* duplicate with `VITE_` prefix (e.g. `VITE_AZURE_B2C_CLIENT_ID`) — but only for non-sensitive values.

## Post-Login Provisioning

On successful authentication, if an email claim is present, the client calls:

```ts
fetch('/api/auth/ensure-user', {
  method: 'POST',
  headers: { 'content-type': 'application/json' },
  body: JSON.stringify({ email: userInfo.email, displayName: userInfo.displayName })
});
```

This is a lightweight pattern to create (or idempotently upsert) the user in your database without blocking the UI. Consider adding retry logic + exponential backoff later.

## Error Handling Strategy

- MSAL warnings suppressed unless elevated (current log level: `Warning`)
- All thrown errors during init/sign-in captured into `auth.error`
- `InteractionRequiredAuthError` triggers sign-in flow retry *only* when a token is actually needed
- Improvement avenue: dedicated toast/notification system & structured error codes

## Security Considerations (Today vs Future)

| Area | Current | Planned Enhancement |
|------|---------|---------------------|
| Token cache | localStorage | switch to sessionStorage (defense-in-depth) |
| XSS hardening | Rely on Svelte escaping | CSP + stricter headers |
| API binding | Ad hoc fetch with `getAccessToken()` | central API client with 401 auto-recovery |
| Claims handling | Basic extraction | schema validation + claim versioning |
| Metrics | None | login latency + silent token success ratio |

## Roadmap (Concrete Next Steps)

1. Introduce `apiClient.ts` with automatic token injection & clock skew retries
2. Add `<AuthGate>` component (slot gating + skeleton state)
3. Replace `localStorage` with `sessionStorage` & document trade-offs
4. Implement a password reset flow trigger (separate policy)
5. Add server-side JWT validation middleware for protected endpoints
6. Add unit tests around edge cases (no account, expired token, interaction required)

## Troubleshooting Guide

| Symptom | Likely Cause | Resolution |
|---------|-------------|------------|
| Infinite redirect | Redirect URI mismatch | Align Azure portal + env + `redirectUri` |
| `AADB2C90205` | Policy name typo | Verify casing & policy name |
| `InteractionRequiredAuthError` in console | Silent token cannot refresh | Call `signIn()` again or re-check scopes |
| Empty `emails` claim | User flow not emitting email | Add email to user attributes in B2C policy |
| 401 from backend | Missing Authorization header | Ensure you pass token from `getAccessToken()` |

## Checklist for Adding a New Protected API Call

1. Ensure user is authenticated (`auth.isAuthenticated`)
2. Obtain token: `const token = await auth.getAccessToken(['openid','profile'])` (add custom scope later)
3. Attach header: `Authorization: Bearer ${token}`
4. Handle 401 -> optionally force `auth.signIn()`
5. Consider exponential retry for transient network errors

## References

- MSAL.js: [msal-overview](https://learn.microsoft.com/azure/active-directory/develop/msal-overview)
- Azure AD B2C User Flows: [user-flow-overview](https://learn.microsoft.com/azure/active-directory-b2c/user-flow-overview)
- Auth Code + PKCE for SPAs: [v2-oauth2-auth-code-flow](https://learn.microsoft.com/azure/active-directory/develop/v2-oauth2-auth-code-flow)
- SvelteKit Docs: [Docs](https://kit.svelte.dev/docs)

## Final Thoughts

Auth does not need to start as a sprawling abstraction. Begin with a minimal, legible service (as here), confirm real usage patterns, then iterate deliberately. This keeps cognitive load down and avoids premature complexity while still grounding you in battle-tested identity primitives from Azure AD B2C.

If you adopt any of the roadmap steps, revisit this document and evolve it—treat docs as part of the product surface, not an afterthought.
